\section{The Language of Design}
%
\index{F!forth@\Forth{}!design@as design language|(}
\Forth{} is a design language. To the student of traditional computer
science, this statement is self-contradictory. ``One doesn't design
with a language, one implements with a language.  Design precedes
implementation.''

Experienced \Forth{} programmers disagree. In \Forth{} you can write
abstract, design-level code and still be able to test it at any time
by taking advantage of decomposition into lexicons. A component can
easily be rewritten, as development proceeds, underneath any
components that use it. At first the words in a component may print
numbers on your terminal instead of controlling stepper motors. They
may print their own names just to let you know they've executed. They
may do nothing at all.

Using this philosophy you can write a simple but testable version of
your application, then successively change and refine it until you
reach your goal.

Another factor that makes designing in code possible is that \Forth{},
like some of the newer languages, eliminates the ``batch-compile''%
\index{B!Batch-compile development sequence!elimination of}
development sequence (edit-compile-test-edit-compile-test). Because
the feedback is instantaneous, the medium becomes a partner in the
creative process. The programmer using a batch-compiler language can
seldom achieve the productive state of mind that artists achieve when
the creative current flows unhindered.

For these reasons, \Forth{} programmers spend less time planning than
their classical counterparts, who feel righteous about planning. To
them, not planning seems reckless and irresponsible. Traditional
environments force programmers to plan because traditional programming
languages do not readily accommodate change.

Unfortunately, human foresight is limited even under the best
conditions.  Too much planning becomes counterproductive.

Of course \Forth{} doesn't eliminate planning. It allows prototyping.%
\index{P!Prototyping}
Constructing a prototype is a more refined way to plan, just as
breadboarding is in electronic design.

As we'll see in the next chapter, experimentation proves more reliable
in arriving at the truth than the guesswork of planning.%
\index{F!forth@\Forth{}!design@as design language|)}


